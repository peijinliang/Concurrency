# 消息队列

###消息队列特性

    业务无关：只做消息分发
    FIFP:先投递先到达
    容灾：节点的动态增删和消息的持久化
    性能：吞吐量提升，系统的内部通信效率提高

###为什么需要消息队列呢？
    
    生产 和 消费 的速度或者稳定性等因素不一致

### 消息队列好处

    业务解耦
    最终一致性(Kafka、RabbitMQ、RocketMQ)
    广播
    错峰与流控

#### Kafka

#### RabbitMQ
 
#### RocketMQ

### RPC 远程调用

### 应用拆分

#### 应用拆分原则

    
    业务优先
    循序渐进(拆分、测试)
    兼顾技术(重构、分层)
    可靠测试

   
#### 应用拆分思考

    应用之间通信： RPC(dobbo等)、消息队列
    1）消息通知：数据请求数据包小，但是数据量大，对实时性要求不高的场景
    
    2）RPC(dobbo等): 对实时性要求更高一些 
    (并不是使用webservice或者http，而是配置好之后像调用本地方法一下，无感知。)
    
    应用之间的数据库设计：每个应用都有独立的数据库
    
    尽量避免事   务操作跨应用

###Dubbo 和 SpringCloud

    Dubbo : 分布式服务框架，提供满负载均衡、监控中心和调用中心(单独配置)
   
    ZooKeeper:
    Webservice： 服务式框架，并不是服务式的，他需要其他组件实现负载均衡
    SpringCloud：

### 微服务


###限流算法
    
    计数器法： 最简单，最容易。
    滑动窗口算法：需要更多的存储空间。
    
    漏桶算法：Leaky Bucket  恒定的速率来获得请求
    令牌桶算法：允许某些请求的突发。

###服务降级  服务熔断

####服务降级：
    
    服务器当压力剧增的时候，根据当前业务情况及流量，对一些服务和页面进行有策略的降级。
    以此缓解服务器资源的的压力，以保证核心业务的正常运行，同时也保持了客户和大部分客户的得到
    正确的相应。
    
    简单来讲：服务器处理不了，那么就给一个默认返回页面。
    根据不同的接口做默认的返回和定制，这样就比较灵活。
    
    
    自动降级：超时、失败次数、故障、限流
       配置好超时时间(异步机制探测回复情况)； 
       不稳的的api调用次数达到一定数量进行降级(异步机制探测回复情况)；
       调用的远程服务出现故障(dns、http服务错误状态码、网络故障、Rpc服务异常)，直接进行讲解。 
       
    人工降级：秒杀、双十一大促
       降级非重要的服务。

###服务熔断：
    
    软件系统里边因为又某些原因，是服务出现过载的现象，为了防止防止整个系统的故障，而采用了一些保护
    措施。过载保护。
    
    
    共性：目的、最终表现、粒度、自治
    区别： 触发原因、管理目标层次、实现方式


###服务降级考虑问题？

    核心服务、非核心服务
    是否支持降级，降级策略
    业务放通场景，策略

###Hystrix(简单实现服务降级和服务熔断)
    
    在通过第三方客户端访问(通常通过网络)依赖服务出现高延迟或者失败的时候，为系统提供保护和控制
    在分布式系统中防止级联失败
    快速失败(Fail Fast )同时能快速恢复
    提供失败回退(Fallback)和优雅的服务降级机制
    提供近实时的监控、报警和运维控制手段

###数据库切库、分库、分表(手记)

数据库瓶颈：

    单个数据库数据量太大(1-2T)：多个库
    单个数据库服务器压力太大，读写瓶颈：多个库
    单个表数据量过大：分表
    
    切库的基础：读写分离 ( 主库：分库：)
    自定义注解完成数据库切库：代码实现

### 多个数据源的支持
       
    横向(水平)分表
    纵向(垂直)分表
    数据分表：mybatis分表插件sharebatis2.0

###高可用的系统
    
    任务调度系统分布式： elastic-job(当当) +zookeeper

    elastic-job：弹性扩容和数据分片
    
    主备切换：apache curator + zookeeper 分布式锁实现


监控报警机制(手记)
