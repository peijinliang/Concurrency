# 死锁
  两个或者两个以上的进程在执行过程中为了竞争资源，而陷入相互等待的状态,如果没有外力的作用，
  他们就无法继续推进下去。
  
###死锁发生四个必要条件:

1)互斥条件  
进程对分配到的资源进行排他性使用，在一段时间内某资源只有一个资源占用，如果此时还有其他的进程请求资源，那么请求者只能等待。
直到占有资源的进程用完，释放出来。

2)请求和保持条件 
进程已经占有一个资源，但是又有新的资源请求，而该资源已经被其他进程占有。此时进程阻塞，但是又对自己已经获得的资源不释放。

3)不剥夺条件 进程
进程已经获得资源在未使用完之前，不能被剥夺，只能在使用完之后进行释放。

4)环路等待条件
发生死锁的时候，一定发生一个进程，他是资源一个环形的链。

###如何避免死锁？

1)设置加锁循序
2)设置加锁给定时间
3)死锁检测 

###死锁之后都能做那一些事情呢?

1) 回退和等待
2) 线程设置随机的优先级



#多线程的并发实践
    
1)使用本地变量
2)使用不可变的类
3)最小化锁的作用域范围： S = 1/(1-a + a/n)
4)使用线城池的Executor,而不是直接new Thread() 执行
5)宁可使用同步也不要使用线程的wait和notify
6)使用BlockingQueue实现-消费模式
7)使用并发集合而不是使用加了锁的同步集合
8)使用Semaphore创建有界的访问
9)宁可使用同步的代码块，也不使用同步的方法
10)避免使用静态变量

#Spring 与 线程安全(模糊)

Spring bean(两种状态): singleton (单例模式) 、prototype (每一次都创建一个对象)
 
无状态对象(线程安全)：
dto 、vo 、service 、controller 


#HashMap 与 ConcurrentHashMap(模糊)

1、HashMap 通过数组和列表结构构成。
2、初始容量和加载因子 决定HashMap 的效率，调用resize()方法进行扩容，
然后创建新的新的数组，将原来的数据copy到新的数组中，此操作称为reHash,
线程不安全出现死锁。
3、HashMap 寻址方式：
4、HashMap 线程是线程不安全的 ： resize()方法和使用迭代器报错

###扩容

垂直扩容(纵向扩容)：
    提高系统部件能力
        
水平扩容(横向扩容)：
    增加更多系统成员显示





